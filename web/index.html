<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gastown Dashboard</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
    background: #0d1117;
    color: #c9d1d9;
    height: 100vh;
    overflow: hidden;
  }

  .container {
    display: grid;
    grid-template-columns: 260px 1fr;
    height: 100vh;
  }

  /* --- Left panel: agent list --- */
  .sidebar {
    background: #161b22;
    border-right: 1px solid #30363d;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .sidebar-header {
    padding: 16px;
    border-bottom: 1px solid #30363d;
    font-size: 14px;
    font-weight: 600;
    color: #e6edf3;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .sidebar-title {
    font-size: 13px;
    color: #8b949e;
    letter-spacing: 0.4px;
  }

  .agent-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
  }

  .agent-card {
    padding: 10px 12px;
    border-radius: 6px;
    cursor: pointer;
    margin-bottom: 4px;
    border: 1px solid transparent;
    transition: background 0.15s, border-color 0.15s;
  }

  .agent-card:hover { background: #1c2128; }
  .agent-card.selected { background: #1c2128; border-color: #58a6ff; }

  .agent-name {
    font-size: 13px;
    font-weight: 600;
    color: #e6edf3;
    display: flex;
    align-items: center;
    gap: 6px;
    flex-wrap: wrap;
    overflow-wrap: anywhere;
  }

  .agent-meta {
    font-size: 11px;
    color: #8b949e;
    margin-top: 4px;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .badge {
    font-size: 10px;
    padding: 1px 6px;
    border-radius: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .badge-role {
    color: #0d1117;
  }

  .badge-attached {
    background: #1f6feb33;
    color: #58a6ff;
  }

  .badge-runtime {
    color: #8b949e;
  }

  /* Role colors */
  .role-mayor    { background: #da3633; }
  .role-deacon   { background: #a371f7; }
  .role-overseer { background: #58a6ff; }
  .role-witness  { background: #3fb950; }
  .role-refinery { background: #d29922; }
  .role-crew     { background: #f778ba; }
  .role-polecat  { background: #79c0ff; }
  .role-boot     { background: #8b949e; }

  /* --- Right panel: terminal viewer --- */
  .main {
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .main-header {
    padding: 12px 16px;
    border-bottom: 1px solid #30363d;
    font-size: 13px;
    color: #8b949e;
    background: #161b22;
    display: flex;
    align-items: center;
    gap: 8px;
    min-height: 44px;
    flex-wrap: nowrap;
  }

  .header-content {
    display: flex;
    align-items: center;
    gap: 8px;
    flex: 1;
    min-width: 0;
    overflow: hidden;
    white-space: nowrap;
  }

  .main-header .agent-label {
    color: #e6edf3;
    font-weight: 600;
    overflow-wrap: anywhere;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .connection-status {
    margin-left: auto;
    display: flex;
    align-items: center;
    gap: 6px;
    color: #58a6ff;
    font-size: 12px;
    font-weight: 600;
    white-space: nowrap;
    flex-shrink: 0;
  }

  .connection-status .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #3fb950;
    flex-shrink: 0;
  }

  .connection-status .dot.disconnected { background: #f85149; }

  .output-wrap {
    flex: 1;
    overflow: hidden;
    position: relative;
  }

  .terminal-wrapper {
    width: 100%;
    height: 100%;
    display: none;
    position: relative;
    overflow: hidden;
  }

  .terminal-wrapper.active {
    display: block;
  }

  .terminal-host {
    width: 100%;
    height: 100%;
    transform-origin: top left;
    will-change: transform;
  }

  .terminal-wrapper.drag-over::after {
    content: 'Drop files to upload and paste';
    position: absolute;
    inset: 16px;
    border: 2px dashed #58a6ff;
    border-radius: 8px;
    background: rgba(13, 17, 23, 0.85);
    color: #58a6ff;
    font-size: 13px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 5;
  }

  .placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #484f58;
    font-size: 14px;
  }

  .empty-sidebar {
    padding: 16px;
    color: #484f58;
    font-size: 12px;
    text-align: center;
  }

  .agent-list-state {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    min-height: 56px;
    padding: 12px;
    color: #8b949e;
    font-size: 12px;
    text-align: center;
  }

  .agent-list-state.timeout {
    color: #f0883e;
  }

  .spinner {
    width: 12px;
    height: 12px;
    border: 2px solid #30363d;
    border-top-color: #58a6ff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    flex-shrink: 0;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .mobile-nav-btn,
  .sidebar-close {
    display: none;
    border: 1px solid #30363d;
    background: #0d1117;
    color: #c9d1d9;
    border-radius: 6px;
    font-size: 18px;
    font-weight: 700;
    line-height: 1;
    width: 32px;
    height: 30px;
    padding: 0;
    cursor: pointer;
  }

  .sidebar-close {
    margin-left: auto;
    font-size: 20px;
  }

  .drawer-backdrop {
    display: none;
  }

  @media (max-width: 900px) {
    .container {
      grid-template-columns: 1fr;
      height: 100vh;
      min-height: 100vh;
    }

    .sidebar {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: min(86vw, 340px);
      border-right: 1px solid #30363d;
      border-bottom: 0;
      transform: translateX(-100%);
      transition: transform 0.2s ease;
      z-index: 50;
      box-shadow: 12px 0 28px rgba(0, 0, 0, 0.4);
      min-height: 100vh;
    }

    body.drawer-open .sidebar {
      transform: translateX(0);
    }

    .drawer-backdrop {
      display: block;
      position: fixed;
      inset: 0;
      background: rgba(1, 4, 9, 0.62);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 40;
    }

    body.drawer-open .drawer-backdrop {
      opacity: 1;
      pointer-events: auto;
    }

    .main {
      min-width: 0;
    }

    .sidebar-header {
      padding: 10px 12px;
      font-size: 13px;
      min-height: 40px;
      position: sticky;
      top: 0;
      background: #161b22;
      z-index: 1;
    }

    .sidebar-close {
      margin-left: 0;
      order: -1;
    }

    .sidebar-title {
      margin-left: 4px;
    }

    .agent-list {
      display: block;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 10px;
    }

    .empty-sidebar {
      min-width: 0;
    }

    .agent-card {
      min-width: 0;
      max-width: none;
      margin-bottom: 6px;
    }

    .main-header {
      padding: 10px 12px;
      font-size: 12px;
      min-height: 40px;
      gap: 6px;
    }

    .mobile-nav-btn,
    .sidebar-close {
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .header-content {
      gap: 6px;
    }

    .connection-status {
      font-size: 11px;
      gap: 5px;
    }

    .placeholder {
      padding: 16px;
      text-align: center;
      font-size: 13px;
    }

    .terminal-wrapper.drag-over::after {
      inset: 10px;
      font-size: 12px;
    }
  }

  @media (max-width: 520px) {
    .agent-card { padding: 9px 10px; }

    .agent-meta {
      font-size: 10px;
      gap: 6px;
    }

    .badge {
      font-size: 9px;
      padding: 1px 5px;
    }
  }
</style>
</head>
<body>
<div class="container">
  <div class="sidebar">
    <div class="sidebar-header">
      <button type="button" class="sidebar-close" id="sidebar-close" aria-label="Close agents drawer">×</button>
      <span class="sidebar-title">Agents</span>
    </div>
    <div class="agent-list" id="agent-list">
      <div class="agent-list-state"><span class="spinner"></span><span>Loading agents...</span></div>
    </div>
  </div>

  <div class="main">
    <div class="main-header" id="main-header">
      <button type="button" class="mobile-nav-btn" id="mobile-nav-btn" aria-label="Open agents drawer">☰</button>
      <div class="header-content" id="header-content">Select an agent to view output</div>
      <div class="connection-status" id="connection-status">
        <span class="dot disconnected" id="status-dot"></span>
        <span id="status-text">Connecting...</span>
      </div>
    </div>
    <div class="output-wrap" id="output-wrap">
      <div class="placeholder" id="placeholder">Select an agent from the sidebar</div>
    </div>
  </div>
</div>
<div class="drawer-backdrop" id="drawer-backdrop"></div>

<script type="module">
import { init, Terminal } from 'https://cdn.jsdelivr.net/npm/ghostty-web/+esm';
await init();

// --- State ---
var agents = new Map();       // name -> agent object
var selectedAgent = null;     // name of currently selected agent
var terminals = new Map();    // name -> { terminal, wrapper }
var msgId = 0;                // monotonic message id
var ws = null;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();
var pendingInitialPaint = new Set(); // agent names waiting for first snapshot paint
var pendingResizePaint = new Set();  // agent names waiting for post-resize repaint
var resizeSendTimers = new Map();    // agent -> debounce timer id
var resizeRevealTimers = new Map();  // agent -> safety reveal timer id
var initialPaintTimers = new Map();  // agent -> safety timeout for initial paint
var agentsLoading = true;
var agentsLoadTimedOut = false;
var agentsLoadTimer = null;

var BinaryTerminalOutput = 0x01;
var BinaryKeyboardInput = 0x02;
var BinaryResize = 0x03;
var BinaryFileUpload = 0x04;
var BinaryTerminalSnapshot = 0x05;

var MaxUploadBytes = 8 * 1024 * 1024;
var MinTerminalCols = 80;
var ResizeSendDebounceMs = 90;
var ResizeRevealTimeoutMs = 260;
var AgentsLoadTimeoutMs = 7000;
var InitialPaintTimeoutMs = 3000;

// --- DOM refs ---
var agentListEl  = document.getElementById('agent-list');
var outputWrapEl = document.getElementById('output-wrap');
var headerContentEl = document.getElementById('header-content');
var placeholderEl = document.getElementById('placeholder');
var statusDot    = document.getElementById('status-dot');
var statusText   = document.getElementById('status-text');
var mobileNavBtn = document.getElementById('mobile-nav-btn');
var sidebarCloseBtn = document.getElementById('sidebar-close');
var drawerBackdropEl = document.getElementById('drawer-backdrop');

// --- Helpers: safe DOM construction ---
function createBadge(text, classNames) {
  var el = document.createElement('span');
  el.textContent = text;
  el.className = classNames;
  return el;
}

function clearChildren(el) {
  while (el.firstChild) el.removeChild(el.firstChild);
}

function setTerminalHostVisibility(agentName, visible) {
  var entry = terminals.get(agentName);
  if (!entry) return;
  entry.host.style.visibility = visible ? '' : 'hidden';
}

function clearAgentsLoadTimer() {
  if (!agentsLoadTimer) return;
  clearTimeout(agentsLoadTimer);
  agentsLoadTimer = null;
}

function startAgentsLoading() {
  agentsLoading = true;
  agentsLoadTimedOut = false;
  clearAgentsLoadTimer();
  agentsLoadTimer = setTimeout(function() {
    if (!agentsLoading) return;
    agentsLoading = false;
    agentsLoadTimedOut = true;
    renderAgentList();
  }, AgentsLoadTimeoutMs);
  renderAgentList();
}

function markAgentsLoaded() {
  agentsLoading = false;
  agentsLoadTimedOut = false;
  clearAgentsLoadTimer();
}

function clearResizeRevealTimer(agentName) {
  var timer = resizeRevealTimers.get(agentName);
  if (timer) {
    clearTimeout(timer);
    resizeRevealTimers.delete(agentName);
  }
}

function clearInitialPaintTimer(agentName) {
  var timer = initialPaintTimers.get(agentName);
  if (timer) {
    clearTimeout(timer);
    initialPaintTimers.delete(agentName);
  }
}

function startInitialPaint(agentName) {
  pendingInitialPaint.add(agentName);
  clearInitialPaintTimer(agentName);
  initialPaintTimers.set(agentName, setTimeout(function() {
    initialPaintTimers.delete(agentName);
    if (!pendingInitialPaint.has(agentName)) return;
    pendingInitialPaint.delete(agentName);
    setTerminalHostVisibility(agentName, true);
    var entry = terminals.get(agentName);
    if (entry && entry.wrapper.classList.contains('active')) {
      fitTerminal(entry);
    }
  }, InitialPaintTimeoutMs));
}

function finishInitialPaint(agentName) {
  pendingInitialPaint.delete(agentName);
  clearInitialPaintTimer(agentName);
}

function finishResizePending(agentName) {
  if (!pendingResizePaint.has(agentName)) return;
  pendingResizePaint.delete(agentName);
  clearResizeRevealTimer(agentName);
  setTerminalHostVisibility(agentName, true);
}

function markResizePending(agentName) {
  if (pendingInitialPaint.has(agentName)) return;
  pendingResizePaint.add(agentName);
  setTerminalHostVisibility(agentName, false);
  clearResizeRevealTimer(agentName);

  var timer = setTimeout(function() {
    pendingResizePaint.delete(agentName);
    resizeRevealTimers.delete(agentName);
    setTerminalHostVisibility(agentName, true);
    var entry = terminals.get(agentName);
    if (entry && entry.wrapper.classList.contains('active')) {
      fitTerminal(entry);
    }
  }, ResizeRevealTimeoutMs);
  resizeRevealTimers.set(agentName, timer);
}

function scheduleResizeSend(agentName, cols, rows) {
  var timer = resizeSendTimers.get(agentName);
  if (timer) clearTimeout(timer);
  resizeSendTimers.set(agentName, setTimeout(function() {
    resizeSendTimers.delete(agentName);
    var payload = textEncoder.encode(cols + ':' + rows);
    sendBinary(BinaryResize, agentName, payload);
  }, ResizeSendDebounceMs));
}

function sendResizeNow(agentName) {
  var entry = terminals.get(agentName);
  if (!entry) return false;
  fitTerminal(entry);
  var payload = textEncoder.encode(entry.terminal.cols + ':' + entry.terminal.rows);
  sendBinary(BinaryResize, agentName, payload);
  return true;
}

function subscribeOutputWithSizedSnapshot(agentName) {
  if (!agentName) return;

  requestAnimationFrame(function() {
    // Ensure the pane size is pushed before subscribe-output so snapshot capture
    // happens at the same geometry the browser will render.
    sendResizeNow(agentName);
    send({ type: 'subscribe-output', agent: agentName });
  });
}

function isMobileLayout() {
  return window.matchMedia('(max-width: 900px)').matches;
}

function openDrawer() {
  if (!isMobileLayout()) return;
  document.body.classList.add('drawer-open');
}

function closeDrawer() {
  document.body.classList.remove('drawer-open');
}

function syncMobileNavButton() {
  if (!mobileNavBtn) return;
  mobileNavBtn.textContent = '☰';
  mobileNavBtn.setAttribute('aria-label', 'Open agents drawer');
}

function bindMobileLayoutEvents() {
  if (mobileNavBtn) {
    mobileNavBtn.addEventListener('click', function() {
      if (!isMobileLayout()) return;
      openDrawer();
    });
  }

  if (sidebarCloseBtn) {
    sidebarCloseBtn.addEventListener('click', function() {
      closeDrawer();
    });
  }

  if (drawerBackdropEl) {
    drawerBackdropEl.addEventListener('click', function() {
      closeDrawer();
    });
  }

  var media = window.matchMedia('(max-width: 900px)');
  var onChange = function(ev) {
    if (!ev.matches) {
      closeDrawer();
    } else if (!selectedAgent) {
      openDrawer();
    }
    syncMobileNavButton();
  };
  if (typeof media.addEventListener === 'function') {
    media.addEventListener('change', onChange);
  } else if (typeof media.addListener === 'function') {
    media.addListener(onChange);
  }
}

// --- Terminal fit ---
function getTerminalScreen(el) {
  if (!el) return null;
  return el.querySelector('.xterm-screen') || el.querySelector('canvas');
}

function fitTerminal(entry) {
  var term = entry.terminal;
  var container = entry.wrapper;
  var host = entry.host || entry.wrapper;

  if (!container.clientWidth || !container.clientHeight) return;

  // Reset any width scaling before measuring available columns.
  host.style.width = '100%';
  host.style.transform = 'none';

  // Measure cell dimensions from the rendered terminal screen
  var screen = getTerminalScreen(host);
  if (!screen || !screen.offsetWidth || !screen.offsetHeight) return;

  var cellWidth = screen.offsetWidth / term.cols;
  var cellHeight = screen.offsetHeight / term.rows;

  if (cellWidth <= 0 || cellHeight <= 0) return;

  var naturalCols = Math.max(2, Math.floor(container.clientWidth / cellWidth));
  var newCols = naturalCols < MinTerminalCols ? MinTerminalCols : naturalCols;
  var newRows = Math.max(1, Math.floor(container.clientHeight / cellHeight));

  if (newCols !== term.cols || newRows !== term.rows) {
    term.resize(newCols, newRows);
  }

  // Keep minimum readable layout width (80 cols) by scaling width only.
  // This prevents downstream TUIs from breaking below their expected width.
  if (naturalCols < MinTerminalCols) {
    var requiredWidth = MinTerminalCols * cellWidth;
    if (requiredWidth > 0) {
      var scaleX = Math.min(1, container.clientWidth / requiredWidth);
      host.style.width = requiredWidth + 'px';
      host.style.transform = 'scaleX(' + scaleX + ')';
    }
  }
}

var resizeObserver = new ResizeObserver(function(entries) {
  entries.forEach(function(re) {
    terminals.forEach(function(entry) {
      if (entry.wrapper === re.target && entry.wrapper.classList.contains('active')) {
        fitTerminal(entry);
      }
    });
  });
});

// --- Terminal management ---
function getOrCreateTerminal(agentName) {
  var cached = terminals.get(agentName);
  if (cached) return cached;

  var terminal = new Terminal({
    fontSize: 13,
    scrollback: 10000,
    cursorBlink: true,
    theme: { background: '#0d1117' },
  });
  var wrapper = document.createElement('div');
  wrapper.className = 'terminal-wrapper';
  var host = document.createElement('div');
  host.className = 'terminal-host';
  wrapper.appendChild(host);
  outputWrapEl.appendChild(wrapper);
  terminal.open(host);

  // Hide the native cursor until the app positions it via escape sequences.
  // This prevents a phantom cursor at (0,0) before the app takes control.
  terminal.write('\x1b[?25l');

  // Some browsers treat Shift+Tab as focus traversal before terminal input
  // handling kicks in. Capture it explicitly and send Backtab (CSI Z).
  if (typeof terminal.attachCustomKeyEventHandler === 'function') {
    terminal.attachCustomKeyEventHandler(function(ev) {
      if (ev.key === 'Tab' && ev.shiftKey && !ev.ctrlKey && !ev.altKey && !ev.metaKey) {
        ev.preventDefault();
        ev.stopPropagation();
        sendBinary(BinaryKeyboardInput, agentName, new Uint8Array([0x1b, 0x5b, 0x5a]));
        return true;
      }
      return false;
    });
  }

  // Keyboard input -> server via binary
  terminal.onData(function(data) {
    // If user starts typing while scrolled up, jump to live bottom so input is visible.
    if (typeof terminal.scrollToBottom === 'function') {
      terminal.scrollToBottom();
    }
    var payload = textEncoder.encode(data);
    sendBinary(BinaryKeyboardInput, agentName, payload);
  });

  // Terminal resize -> server via binary.
  // During initial paint, suppress resize sends — the initial resize was
  // already sent by subscribeOutputWithSizedSnapshot. Sending more resizes
  // during the transition causes a cascade of SIGWINCH events that corrupts
  // the app's display state.
  terminal.onResize(function(size) {
    if (pendingInitialPaint.has(agentName)) {
      return;
    }
    markResizePending(agentName);
    scheduleResizeSend(agentName, size.cols, size.rows);
  });

  wireFileTransferHandlers(wrapper, agentName);

  resizeObserver.observe(wrapper);

  var entry = { terminal: terminal, wrapper: wrapper, host: host };
  terminals.set(agentName, entry);
  return entry;
}

function showTerminal(agentName) {
  // Hide all terminal wrappers
  terminals.forEach(function(entry) {
    entry.wrapper.classList.remove('active');
  });

  // Show or create the target terminal
  var entry = getOrCreateTerminal(agentName);
  entry.wrapper.classList.add('active');
  entry.host.style.visibility = (pendingInitialPaint.has(agentName) || pendingResizePaint.has(agentName)) ? 'hidden' : '';
  placeholderEl.style.display = 'none';

  // Fit after layout settles, then focus for immediate typing
  requestAnimationFrame(function() {
    fitTerminal(entry);
    entry.terminal.focus();
  });
}

function hideAllTerminals() {
  terminals.forEach(function(entry) {
    entry.wrapper.classList.remove('active');
  });
  placeholderEl.style.display = '';
}

async function sendFiles(agentName, files) {
  if (!files || files.length === 0) return;

  for (var i = 0; i < files.length; i++) {
    var file = files[i];
    if (!file) continue;

    if (file.size > MaxUploadBytes) {
      console.warn('skipping oversized file', file.name, file.size);
      continue;
    }

    var fileBytes = new Uint8Array(await file.arrayBuffer());
    var nameBytes = textEncoder.encode(file.name || 'attachment.bin');
    var mimeBytes = textEncoder.encode(file.type || 'application/octet-stream');

    var payload = new Uint8Array(nameBytes.length + 1 + mimeBytes.length + 1 + fileBytes.length);
    payload.set(nameBytes, 0);
    payload[nameBytes.length] = 0;
    payload.set(mimeBytes, nameBytes.length + 1);
    payload[nameBytes.length + 1 + mimeBytes.length] = 0;
    payload.set(fileBytes, nameBytes.length + 1 + mimeBytes.length + 1);

    sendBinary(BinaryFileUpload, agentName, payload);
  }
}

function hasFiles(dataTransfer) {
  if (!dataTransfer || !dataTransfer.types) return false;
  for (var i = 0; i < dataTransfer.types.length; i++) {
    if (dataTransfer.types[i] === 'Files') return true;
  }
  return false;
}

function wireFileTransferHandlers(wrapper, agentName) {
  var dragDepth = 0;

  wrapper.addEventListener('dragenter', function(ev) {
    if (!hasFiles(ev.dataTransfer)) return;
    ev.preventDefault();
    dragDepth += 1;
    wrapper.classList.add('drag-over');
  });

  wrapper.addEventListener('dragover', function(ev) {
    if (!hasFiles(ev.dataTransfer)) return;
    ev.preventDefault();
    if (ev.dataTransfer) ev.dataTransfer.dropEffect = 'copy';
  });

  wrapper.addEventListener('dragleave', function(ev) {
    ev.preventDefault();
    dragDepth = Math.max(0, dragDepth - 1);
    if (dragDepth === 0) wrapper.classList.remove('drag-over');
  });

  wrapper.addEventListener('drop', function(ev) {
    ev.preventDefault();
    dragDepth = 0;
    wrapper.classList.remove('drag-over');
    if (!hasFiles(ev.dataTransfer)) return;

    sendFiles(agentName, ev.dataTransfer.files).catch(function(err) {
      console.error('drop upload failed', err);
    });
  });

  wrapper.addEventListener('paste', function(ev) {
    var files = ev.clipboardData && ev.clipboardData.files;
    if (!files || files.length === 0) return;
    ev.preventDefault();

    sendFiles(agentName, files).catch(function(err) {
      console.error('paste upload failed', err);
    });
  });
}

// --- Binary protocol ---
function sendBinary(type, agentName, payload) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  var nameBytes = textEncoder.encode(agentName);
  var buf = new Uint8Array(1 + nameBytes.length + 1 + payload.length);
  buf[0] = type;
  buf.set(nameBytes, 1);
  buf[1 + nameBytes.length] = 0; // null separator
  buf.set(payload, 1 + nameBytes.length + 1);
  ws.send(buf.buffer);
}

function parseBinaryMessage(buffer) {
  var bytes = new Uint8Array(buffer);
  var msgType = bytes[0];

  // Find null terminator after agent name
  var nullIdx = 1;
  while (nullIdx < bytes.length && bytes[nullIdx] !== 0) nullIdx++;

  var agentName = textDecoder.decode(bytes.slice(1, nullIdx));
  var payload = bytes.slice(nullIdx + 1);

  return { msgType: msgType, agentName: agentName, payload: payload };
}

function getViewportY(term) {
  if (typeof term.getViewportY === 'function') {
    return term.getViewportY();
  }
  if (term.buffer && term.buffer.active && typeof term.buffer.active.viewportY === 'number') {
    return term.buffer.active.viewportY;
  }
  return 0;
}

function getBottomY(term) {
  // ghostty-web exposes viewport position via getViewportY(), where 0 is bottom.
  if (typeof term.getViewportY === 'function') {
    return 0;
  }
  if (term.buffer && term.buffer.active && typeof term.buffer.active.baseY === 'number') {
    return term.buffer.active.baseY;
  }
  return 0;
}

function isAtBottom(term, y) {
  return Math.abs(y - getBottomY(term)) < 0.5;
}

// --- WebSocket ---
function connect() {
  var proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  var wsURL = new URL(proto + '//' + location.host + '/ws');
  var token = new URLSearchParams(location.search).get('token');
  if (token) {
    wsURL.searchParams.set('token', token);
  }
  ws = new WebSocket(wsURL.toString());
  ws.binaryType = 'arraybuffer';

  ws.onopen = function() {
    statusDot.classList.remove('disconnected');
    statusText.textContent = 'Connected';
    if (agents.size === 0) {
      startAgentsLoading();
    }
    send({ type: 'subscribe-agents' });

    // Re-subscribe to selected agent's output
    if (selectedAgent) {
      finishResizePending(selectedAgent);
      startInitialPaint(selectedAgent);
      var selectedEntry = terminals.get(selectedAgent);
      if (selectedEntry) selectedEntry.host.style.visibility = 'hidden';
      showTerminal(selectedAgent);
      subscribeOutputWithSizedSnapshot(selectedAgent);
    }
  };

  ws.onclose = function() {
    statusDot.classList.add('disconnected');
    statusText.textContent = 'Disconnected';
    if (agents.size === 0) {
      startAgentsLoading();
    }
    setTimeout(connect, 2000);
  };

  ws.onmessage = function(ev) {
    if (typeof ev.data === 'string') {
      handleJsonMessage(JSON.parse(ev.data));
    } else if (ev.data instanceof ArrayBuffer) {
      handleBinaryMessage(ev.data);
    }
  };
}

function send(obj) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return null;
  obj.id = String(++msgId);
  ws.send(JSON.stringify(obj));
  return obj.id;
}

// --- Binary message handling ---
function handleBinaryMessage(buffer) {
  var parsed = parseBinaryMessage(buffer);

  var entry = terminals.get(parsed.agentName);
  if (!entry) return;

  if (parsed.msgType === BinaryTerminalSnapshot) {
    setTerminalHostVisibility(parsed.agentName, false);
    if (typeof entry.terminal.reset === 'function') {
      entry.terminal.reset();
      entry.terminal.write('\x1b[?25l');
    } else if (typeof entry.terminal.clear === 'function') {
      entry.terminal.clear();
    }
    entry.terminal.write(parsed.payload);

    requestAnimationFrame(function() {
      requestAnimationFrame(function() {
        finishInitialPaint(parsed.agentName);
        finishResizePending(parsed.agentName);
        setTerminalHostVisibility(parsed.agentName, true);
        if (entry.wrapper.classList.contains('active')) {
          fitTerminal(entry);
        }
      });
    });
    return;
  }

  if (parsed.msgType !== BinaryTerminalOutput) {
    return;
  }

  if (pendingInitialPaint.has(parsed.agentName)) {
    entry.terminal.write(parsed.payload);
    return;
  }

  if (pendingResizePaint.has(parsed.agentName)) {
    entry.terminal.write(parsed.payload);
    requestAnimationFrame(function() {
      requestAnimationFrame(function() {
        finishResizePending(parsed.agentName);
        setTerminalHostVisibility(parsed.agentName, true);
        if (entry.wrapper.classList.contains('active')) {
          fitTerminal(entry);
        }
      });
    });
    return;
  }

  var savedY = getViewportY(entry.terminal);
  var atBottom = isAtBottom(entry.terminal, savedY);
  entry.terminal.write(parsed.payload);

  // ghostty-web write() is synchronous, and rendering happens on the next
  // animation frame. Restoring immediately avoids a visible "jump to bottom
  // then back" flash while preserving sticky scroll.
  if (!atBottom && typeof entry.terminal.scrollToLine === 'function') {
    entry.terminal.scrollToLine(savedY);
  }
}

// --- JSON message handling ---
function handleJsonMessage(msg) {
  switch (msg.type) {
    case 'subscribe-agents':
      agents.clear();
      if (msg.agents) msg.agents.forEach(function(a) { agents.set(a.name, a); });
      markAgentsLoaded();
      renderAgentList();
      break;

    case 'agent-added':
      if (msg.agent) agents.set(msg.agent.name, msg.agent);
      renderAgentList();
      break;

    case 'agent-removed':
      var removedName = msg.name || (msg.agent && msg.agent.name);
      if (removedName) {
        finishInitialPaint(removedName);
        finishResizePending(removedName);
        clearResizeRevealTimer(removedName);
        var resizeSendTimer = resizeSendTimers.get(removedName);
        if (resizeSendTimer) {
          clearTimeout(resizeSendTimer);
          resizeSendTimers.delete(removedName);
        }
        agents.delete(removedName);
        // Clean up terminal
        var removed = terminals.get(removedName);
        if (removed) {
          removed.wrapper.remove();
          terminals.delete(removedName);
        }
        if (selectedAgent === removedName) deselectAgent();
      }
      renderAgentList();
      break;

    case 'agent-updated':
      if (msg.agent) agents.set(msg.agent.name, msg.agent);
      renderAgentList();
      if (msg.agent && msg.agent.name === selectedAgent) updateHeader();
      break;

    case 'subscribe-output':
      // subscribe-output ack only confirms streaming is active.
      break;

    case 'send-prompt':
      // Acknowledgment of programmatic prompt send
      break;

    case 'error':
      console.error('ws error:', msg.error || msg);
      break;
  }
}

// --- Agent list rendering (safe DOM methods) ---
function renderAgentList() {
  clearChildren(agentListEl);

  if (agentsLoading) {
    var loading = document.createElement('div');
    loading.className = 'agent-list-state';
    var spinner = document.createElement('span');
    spinner.className = 'spinner';
    loading.appendChild(spinner);
    var loadingText = document.createElement('span');
    loadingText.textContent = 'Loading agents...';
    loading.appendChild(loadingText);
    agentListEl.appendChild(loading);
    return;
  }

  if (agents.size === 0) {
    var empty = document.createElement('div');
    empty.className = 'agent-list-state' + (agentsLoadTimedOut ? ' timeout' : '');
    empty.textContent = agentsLoadTimedOut ? 'Agent list load timed out' : 'No agents running';
    agentListEl.appendChild(empty);
    return;
  }

  var sorted = Array.from(agents.values()).sort(function(a, b) {
    return a.name.localeCompare(b.name);
  });

  sorted.forEach(function(agent) {
    var card = document.createElement('div');
    card.className = 'agent-card' + (agent.name === selectedAgent ? ' selected' : '');
    card.addEventListener('click', function() { selectAgent(agent.name); });

    // Name row
    var nameRow = document.createElement('div');
    nameRow.className = 'agent-name';
    nameRow.appendChild(createBadge(agent.role || '?', 'badge badge-role role-' + (agent.role || 'boot')));
    var nameSpan = document.createElement('span');
    nameSpan.textContent = agent.name;
    nameRow.appendChild(nameSpan);
    card.appendChild(nameRow);

    // Meta row
    var metaRow = document.createElement('div');
    metaRow.className = 'agent-meta';
    metaRow.appendChild(createBadge(agent.runtime || '?', 'badge-runtime'));
    if (agent.attached) {
      metaRow.appendChild(createBadge('attached', 'badge badge-attached'));
    }
    card.appendChild(metaRow);

    agentListEl.appendChild(card);
  });
}

// --- Agent selection ---
function selectAgent(name) {
  if (selectedAgent === name) {
    if (isMobileLayout()) {
      closeDrawer();
    }
    syncMobileNavButton();
    return;
  }

  // Unsubscribe from previous
  if (selectedAgent) {
    send({ type: 'unsubscribe-output', agent: selectedAgent });
  }

  selectedAgent = name;
  finishResizePending(name);
  startInitialPaint(name);
  updateHeader();
  renderAgentList();

  // Show terminal immediately so selection never appears "stuck" on placeholder.
  // subscribe-output is sent after we push current size to avoid bad initial wraps.
  showTerminal(name);

  // Push size first, then request snapshot+stream at that geometry.
  subscribeOutputWithSizedSnapshot(name);

  if (isMobileLayout()) {
    closeDrawer();
  }
  syncMobileNavButton();
}

function deselectAgent() {
  selectedAgent = null;
  hideAllTerminals();

  clearChildren(headerContentEl);
  headerContentEl.textContent = 'Select an agent to view output';

  renderAgentList();
  if (isMobileLayout()) {
    openDrawer();
  }
  syncMobileNavButton();
}

function updateHeader() {
  if (!selectedAgent) return;
  var agent = agents.get(selectedAgent);
  if (!agent) return;

  clearChildren(headerContentEl);
  headerContentEl.appendChild(createBadge(agent.role || '?', 'badge badge-role role-' + (agent.role || 'boot')));

  var label = document.createElement('span');
  label.className = 'agent-label';
  label.textContent = agent.name;
  headerContentEl.appendChild(label);

  headerContentEl.appendChild(createBadge(agent.runtime || '?', 'badge-runtime'));

  if (agent.attached) {
    headerContentEl.appendChild(createBadge('attached', 'badge badge-attached'));
  }

  syncMobileNavButton();
}

// --- Boot ---
bindMobileLayoutEvents();
startAgentsLoading();
connect();
syncMobileNavButton();
if (isMobileLayout() && !selectedAgent) {
  openDrawer();
}
</script>
</body>
</html>
