<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gastown Dashboard</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'SF Mono', 'Menlo', 'Monaco', 'Consolas', monospace;
    background: #0d1117;
    color: #c9d1d9;
    height: 100vh;
    overflow: hidden;
  }

  .container {
    display: grid;
    grid-template-columns: 260px 1fr;
    height: 100vh;
  }

  /* --- Left panel: agent list --- */
  .sidebar {
    background: #161b22;
    border-right: 1px solid #30363d;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .sidebar-header {
    padding: 16px;
    border-bottom: 1px solid #30363d;
    font-size: 14px;
    font-weight: 600;
    color: #58a6ff;
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .sidebar-header .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: #3fb950;
    flex-shrink: 0;
  }

  .sidebar-header .dot.disconnected { background: #f85149; }

  .agent-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
  }

  .agent-card {
    padding: 10px 12px;
    border-radius: 6px;
    cursor: pointer;
    margin-bottom: 4px;
    border: 1px solid transparent;
    transition: background 0.15s, border-color 0.15s;
  }

  .agent-card:hover { background: #1c2128; }
  .agent-card.selected { background: #1c2128; border-color: #58a6ff; }

  .agent-name {
    font-size: 13px;
    font-weight: 600;
    color: #e6edf3;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .agent-meta {
    font-size: 11px;
    color: #8b949e;
    margin-top: 4px;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .badge {
    font-size: 10px;
    padding: 1px 6px;
    border-radius: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .badge-role {
    color: #0d1117;
  }

  .badge-attached {
    background: #1f6feb33;
    color: #58a6ff;
  }

  .badge-runtime {
    color: #8b949e;
  }

  /* Role colors */
  .role-mayor    { background: #da3633; }
  .role-deacon   { background: #a371f7; }
  .role-overseer { background: #58a6ff; }
  .role-witness  { background: #3fb950; }
  .role-refinery { background: #d29922; }
  .role-crew     { background: #f778ba; }
  .role-polecat  { background: #79c0ff; }
  .role-boot     { background: #8b949e; }

  /* --- Right panel: terminal viewer --- */
  .main {
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  .main-header {
    padding: 12px 16px;
    border-bottom: 1px solid #30363d;
    font-size: 13px;
    color: #8b949e;
    background: #161b22;
    display: flex;
    align-items: center;
    gap: 8px;
    min-height: 44px;
  }

  .main-header .agent-label {
    color: #e6edf3;
    font-weight: 600;
  }

  .output-wrap {
    flex: 1;
    overflow: hidden;
    position: relative;
  }

  .terminal-wrapper {
    width: 100%;
    height: 100%;
    display: none;
    position: relative;
  }

  .terminal-wrapper.active {
    display: block;
  }

  .terminal-wrapper.drag-over::after {
    content: 'Drop files to upload and paste';
    position: absolute;
    inset: 16px;
    border: 2px dashed #58a6ff;
    border-radius: 8px;
    background: rgba(13, 17, 23, 0.85);
    color: #58a6ff;
    font-size: 13px;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 5;
  }

  .placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #484f58;
    font-size: 14px;
  }

  .empty-sidebar {
    padding: 16px;
    color: #484f58;
    font-size: 12px;
    text-align: center;
  }
</style>
</head>
<body>
<div class="container">
  <div class="sidebar">
    <div class="sidebar-header">
      <span class="dot disconnected" id="status-dot"></span>
      <span id="status-text">Connecting...</span>
    </div>
    <div class="agent-list" id="agent-list">
      <div class="empty-sidebar">No agents running</div>
    </div>
  </div>

  <div class="main">
    <div class="main-header" id="main-header">
      Select an agent to view output
    </div>
    <div class="output-wrap" id="output-wrap">
      <div class="placeholder" id="placeholder">Select an agent from the sidebar</div>
    </div>
  </div>
</div>

<script type="module">
import { init, Terminal } from 'https://cdn.jsdelivr.net/npm/ghostty-web/+esm';
await init();

// --- State ---
var agents = new Map();       // name -> agent object
var selectedAgent = null;     // name of currently selected agent
var terminals = new Map();    // name -> { terminal, wrapper }
var msgId = 0;                // monotonic message id
var ws = null;
var textEncoder = new TextEncoder();
var textDecoder = new TextDecoder();

var BinaryTerminalOutput = 0x01;
var BinaryKeyboardInput = 0x02;
var BinaryResize = 0x03;
var BinaryFileUpload = 0x04;

var MaxUploadBytes = 8 * 1024 * 1024;

// --- DOM refs ---
var agentListEl  = document.getElementById('agent-list');
var outputWrapEl = document.getElementById('output-wrap');
var mainHeaderEl = document.getElementById('main-header');
var placeholderEl = document.getElementById('placeholder');
var statusDot    = document.getElementById('status-dot');
var statusText   = document.getElementById('status-text');

// --- Helpers: safe DOM construction ---
function createBadge(text, classNames) {
  var el = document.createElement('span');
  el.textContent = text;
  el.className = classNames;
  return el;
}

function clearChildren(el) {
  while (el.firstChild) el.removeChild(el.firstChild);
}

// --- Terminal fit ---
function fitTerminal(entry) {
  var term = entry.terminal;
  var container = entry.wrapper;

  if (!container.clientWidth || !container.clientHeight) return;

  // Measure cell dimensions from the rendered terminal screen
  var screen = container.querySelector('.xterm-screen') || container.querySelector('canvas');
  if (!screen || !screen.offsetWidth || !screen.offsetHeight) return;

  var cellWidth = screen.offsetWidth / term.cols;
  var cellHeight = screen.offsetHeight / term.rows;

  if (cellWidth <= 0 || cellHeight <= 0) return;

  var newCols = Math.max(2, Math.floor(container.clientWidth / cellWidth));
  var newRows = Math.max(1, Math.floor(container.clientHeight / cellHeight));

  if (newCols !== term.cols || newRows !== term.rows) {
    term.resize(newCols, newRows);
  }
}

var resizeObserver = new ResizeObserver(function(entries) {
  entries.forEach(function(re) {
    terminals.forEach(function(entry) {
      if (entry.wrapper === re.target && entry.wrapper.classList.contains('active')) {
        fitTerminal(entry);
      }
    });
  });
});

// --- Terminal management ---
function getOrCreateTerminal(agentName) {
  var cached = terminals.get(agentName);
  if (cached) return cached;

  var terminal = new Terminal({
    fontSize: 13,
    scrollback: 10000,
    cursorBlink: true,
    theme: { background: '#0d1117' },
  });
  var wrapper = document.createElement('div');
  wrapper.className = 'terminal-wrapper';
  outputWrapEl.appendChild(wrapper);
  terminal.open(wrapper);

  // Hide the native cursor until the app positions it via escape sequences.
  // This prevents a phantom cursor at (0,0) before the app takes control.
  terminal.write('\x1b[?25l');

  // Some browsers treat Shift+Tab as focus traversal before terminal input
  // handling kicks in. Capture it explicitly and send Backtab (CSI Z).
  if (typeof terminal.attachCustomKeyEventHandler === 'function') {
    terminal.attachCustomKeyEventHandler(function(ev) {
      if (ev.key === 'Tab' && ev.shiftKey && !ev.ctrlKey && !ev.altKey && !ev.metaKey) {
        ev.preventDefault();
        ev.stopPropagation();
        sendBinary(BinaryKeyboardInput, agentName, new Uint8Array([0x1b, 0x5b, 0x5a]));
        return true;
      }
      return false;
    });
  }

  // Keyboard input -> server via binary
  terminal.onData(function(data) {
    // If user starts typing while scrolled up, jump to live bottom so input is visible.
    if (typeof terminal.scrollToBottom === 'function') {
      terminal.scrollToBottom();
    }
    var payload = textEncoder.encode(data);
    sendBinary(BinaryKeyboardInput, agentName, payload);
  });

  // Terminal resize -> server via binary
  terminal.onResize(function(size) {
    var payload = textEncoder.encode(size.cols + ':' + size.rows);
    sendBinary(BinaryResize, agentName, payload);
  });

  wireFileTransferHandlers(wrapper, agentName);

  resizeObserver.observe(wrapper);

  var entry = { terminal: terminal, wrapper: wrapper };
  terminals.set(agentName, entry);
  return entry;
}

function showTerminal(agentName) {
  // Hide all terminal wrappers
  terminals.forEach(function(entry) {
    entry.wrapper.classList.remove('active');
  });

  // Show or create the target terminal
  var entry = getOrCreateTerminal(agentName);
  entry.wrapper.classList.add('active');
  placeholderEl.style.display = 'none';

  // Fit after layout settles, then focus for immediate typing
  requestAnimationFrame(function() {
    fitTerminal(entry);
    entry.terminal.focus();
  });
}

function hideAllTerminals() {
  terminals.forEach(function(entry) {
    entry.wrapper.classList.remove('active');
  });
  placeholderEl.style.display = '';
}

async function sendFiles(agentName, files) {
  if (!files || files.length === 0) return;

  for (var i = 0; i < files.length; i++) {
    var file = files[i];
    if (!file) continue;

    if (file.size > MaxUploadBytes) {
      console.warn('skipping oversized file', file.name, file.size);
      continue;
    }

    var fileBytes = new Uint8Array(await file.arrayBuffer());
    var nameBytes = textEncoder.encode(file.name || 'attachment.bin');
    var mimeBytes = textEncoder.encode(file.type || 'application/octet-stream');

    var payload = new Uint8Array(nameBytes.length + 1 + mimeBytes.length + 1 + fileBytes.length);
    payload.set(nameBytes, 0);
    payload[nameBytes.length] = 0;
    payload.set(mimeBytes, nameBytes.length + 1);
    payload[nameBytes.length + 1 + mimeBytes.length] = 0;
    payload.set(fileBytes, nameBytes.length + 1 + mimeBytes.length + 1);

    sendBinary(BinaryFileUpload, agentName, payload);
  }
}

function hasFiles(dataTransfer) {
  if (!dataTransfer || !dataTransfer.types) return false;
  for (var i = 0; i < dataTransfer.types.length; i++) {
    if (dataTransfer.types[i] === 'Files') return true;
  }
  return false;
}

function wireFileTransferHandlers(wrapper, agentName) {
  var dragDepth = 0;

  wrapper.addEventListener('dragenter', function(ev) {
    if (!hasFiles(ev.dataTransfer)) return;
    ev.preventDefault();
    dragDepth += 1;
    wrapper.classList.add('drag-over');
  });

  wrapper.addEventListener('dragover', function(ev) {
    if (!hasFiles(ev.dataTransfer)) return;
    ev.preventDefault();
    if (ev.dataTransfer) ev.dataTransfer.dropEffect = 'copy';
  });

  wrapper.addEventListener('dragleave', function(ev) {
    ev.preventDefault();
    dragDepth = Math.max(0, dragDepth - 1);
    if (dragDepth === 0) wrapper.classList.remove('drag-over');
  });

  wrapper.addEventListener('drop', function(ev) {
    ev.preventDefault();
    dragDepth = 0;
    wrapper.classList.remove('drag-over');
    if (!hasFiles(ev.dataTransfer)) return;

    sendFiles(agentName, ev.dataTransfer.files).catch(function(err) {
      console.error('drop upload failed', err);
    });
  });

  wrapper.addEventListener('paste', function(ev) {
    var files = ev.clipboardData && ev.clipboardData.files;
    if (!files || files.length === 0) return;
    ev.preventDefault();

    sendFiles(agentName, files).catch(function(err) {
      console.error('paste upload failed', err);
    });
  });
}

// --- Binary protocol ---
function sendBinary(type, agentName, payload) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  var nameBytes = textEncoder.encode(agentName);
  var buf = new Uint8Array(1 + nameBytes.length + 1 + payload.length);
  buf[0] = type;
  buf.set(nameBytes, 1);
  buf[1 + nameBytes.length] = 0; // null separator
  buf.set(payload, 1 + nameBytes.length + 1);
  ws.send(buf.buffer);
}

function parseBinaryMessage(buffer) {
  var bytes = new Uint8Array(buffer);
  var msgType = bytes[0];

  // Find null terminator after agent name
  var nullIdx = 1;
  while (nullIdx < bytes.length && bytes[nullIdx] !== 0) nullIdx++;

  var agentName = textDecoder.decode(bytes.slice(1, nullIdx));
  var payload = bytes.slice(nullIdx + 1);

  return { msgType: msgType, agentName: agentName, payload: payload };
}

function getViewportY(term) {
  if (typeof term.getViewportY === 'function') {
    return term.getViewportY();
  }
  if (term.buffer && term.buffer.active && typeof term.buffer.active.viewportY === 'number') {
    return term.buffer.active.viewportY;
  }
  return 0;
}

function getBottomY(term) {
  // ghostty-web exposes viewport position via getViewportY(), where 0 is bottom.
  if (typeof term.getViewportY === 'function') {
    return 0;
  }
  if (term.buffer && term.buffer.active && typeof term.buffer.active.baseY === 'number') {
    return term.buffer.active.baseY;
  }
  return 0;
}

function isAtBottom(term, y) {
  return Math.abs(y - getBottomY(term)) < 0.5;
}

// --- WebSocket ---
function connect() {
  var proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  ws = new WebSocket(proto + '//' + location.host + '/ws');
  ws.binaryType = 'arraybuffer';

  ws.onopen = function() {
    statusDot.classList.remove('disconnected');
    statusText.textContent = 'Connected';
    send({ type: 'subscribe-agents' });

    // Re-subscribe to selected agent's output
    if (selectedAgent) {
      send({ type: 'subscribe-output', agent: selectedAgent });
    }
  };

  ws.onclose = function() {
    statusDot.classList.add('disconnected');
    statusText.textContent = 'Disconnected';
    setTimeout(connect, 2000);
  };

  ws.onmessage = function(ev) {
    if (typeof ev.data === 'string') {
      handleJsonMessage(JSON.parse(ev.data));
    } else if (ev.data instanceof ArrayBuffer) {
      handleBinaryMessage(ev.data);
    }
  };
}

function send(obj) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return null;
  obj.id = String(++msgId);
  ws.send(JSON.stringify(obj));
  return obj.id;
}

// --- Binary message handling ---
function handleBinaryMessage(buffer) {
  var parsed = parseBinaryMessage(buffer);

  if (parsed.msgType === BinaryTerminalOutput) {
    // Terminal output — write to the agent's terminal
    var entry = terminals.get(parsed.agentName);
    if (entry) {
      var savedY = getViewportY(entry.terminal);
      var atBottom = isAtBottom(entry.terminal, savedY);
      entry.terminal.write(parsed.payload);

      // ghostty-web write() is synchronous, and rendering happens on the next
      // animation frame. Restoring immediately avoids a visible "jump to bottom
      // then back" flash while preserving sticky scroll.
      if (!atBottom && typeof entry.terminal.scrollToLine === 'function') {
        entry.terminal.scrollToLine(savedY);
      }
    }
  }
}

// --- JSON message handling ---
function handleJsonMessage(msg) {
  switch (msg.type) {
    case 'subscribe-agents':
      if (msg.agents) msg.agents.forEach(function(a) { agents.set(a.name, a); });
      renderAgentList();
      break;

    case 'agent-added':
      if (msg.agent) agents.set(msg.agent.name, msg.agent);
      renderAgentList();
      break;

    case 'agent-removed':
      var removedName = msg.name || (msg.agent && msg.agent.name);
      if (removedName) {
        agents.delete(removedName);
        // Clean up terminal
        var removed = terminals.get(removedName);
        if (removed) {
          removed.wrapper.remove();
          terminals.delete(removedName);
        }
        if (selectedAgent === removedName) deselectAgent();
      }
      renderAgentList();
      break;

    case 'agent-updated':
      if (msg.agent) agents.set(msg.agent.name, msg.agent);
      renderAgentList();
      if (msg.agent && msg.agent.name === selectedAgent) updateHeader();
      break;

    case 'subscribe-output':
      if (msg.ok && selectedAgent) {
        // Pipe-pane is now active — show terminal and force a resize.
        // The resize triggers SIGWINCH → app redraws → pipe-pane captures it.
        showTerminal(selectedAgent);
        var entry = terminals.get(selectedAgent);
        if (entry) {
          requestAnimationFrame(function() {
            fitTerminal(entry);
            // Always send resize to guarantee a redraw through pipe-pane
            var payload = textEncoder.encode(entry.terminal.cols + ':' + entry.terminal.rows);
            sendBinary(BinaryResize, selectedAgent, payload);
          });
        }
      }
      break;

    case 'send-prompt':
      // Acknowledgment of programmatic prompt send
      break;

    case 'error':
      console.error('ws error:', msg.error || msg);
      break;
  }
}

// --- Agent list rendering (safe DOM methods) ---
function renderAgentList() {
  clearChildren(agentListEl);

  if (agents.size === 0) {
    var empty = document.createElement('div');
    empty.className = 'empty-sidebar';
    empty.textContent = 'No agents running';
    agentListEl.appendChild(empty);
    return;
  }

  var sorted = Array.from(agents.values()).sort(function(a, b) {
    return a.name.localeCompare(b.name);
  });

  sorted.forEach(function(agent) {
    var card = document.createElement('div');
    card.className = 'agent-card' + (agent.name === selectedAgent ? ' selected' : '');
    card.addEventListener('click', function() { selectAgent(agent.name); });

    // Name row
    var nameRow = document.createElement('div');
    nameRow.className = 'agent-name';
    nameRow.appendChild(createBadge(agent.role || '?', 'badge badge-role role-' + (agent.role || 'boot')));
    var nameSpan = document.createElement('span');
    nameSpan.textContent = agent.name;
    nameRow.appendChild(nameSpan);
    card.appendChild(nameRow);

    // Meta row
    var metaRow = document.createElement('div');
    metaRow.className = 'agent-meta';
    metaRow.appendChild(createBadge(agent.runtime || '?', 'badge-runtime'));
    if (agent.attached) {
      metaRow.appendChild(createBadge('attached', 'badge badge-attached'));
    }
    card.appendChild(metaRow);

    agentListEl.appendChild(card);
  });
}

// --- Agent selection ---
function selectAgent(name) {
  if (selectedAgent === name) return;

  // Unsubscribe from previous
  if (selectedAgent) {
    send({ type: 'unsubscribe-output', agent: selectedAgent });
  }

  selectedAgent = name;
  updateHeader();
  renderAgentList();

  // Show terminal immediately so selection never appears "stuck" on placeholder.
  // subscribe-output ack will still trigger a resize/redraw once streaming is active.
  showTerminal(name);

  // Activate streaming; subscribe-output ack will trigger a redraw/resize once
  // pipe-pane is confirmed active on the server.
  send({ type: 'subscribe-output', agent: name });
}

function deselectAgent() {
  selectedAgent = null;
  hideAllTerminals();

  clearChildren(mainHeaderEl);
  mainHeaderEl.textContent = 'Select an agent to view output';

  renderAgentList();
}

function updateHeader() {
  if (!selectedAgent) return;
  var agent = agents.get(selectedAgent);
  if (!agent) return;

  clearChildren(mainHeaderEl);
  mainHeaderEl.appendChild(createBadge(agent.role || '?', 'badge badge-role role-' + (agent.role || 'boot')));

  var label = document.createElement('span');
  label.className = 'agent-label';
  label.textContent = agent.name;
  mainHeaderEl.appendChild(label);

  mainHeaderEl.appendChild(createBadge(agent.runtime || '?', 'badge-runtime'));

  if (agent.attached) {
    mainHeaderEl.appendChild(createBadge('attached', 'badge badge-attached'));
  }
}

// --- Boot ---
connect();
</script>
</body>
</html>
